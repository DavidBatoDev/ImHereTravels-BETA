[
  {
    "id": "gTl0J3RWqWZ9oQiVDOSp",
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1758000099,
      "nanoseconds": 61000000
    },
    "hasGenerics": false,
    "isActive": false,
    "complexity": "simple",
    "exportType": "function",
    "hasExportDefault": true,
    "hasIntersectionTypes": false,
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1758000066,
      "nanoseconds": 700000000
    },
    "arguments": [
      {
        "type": "unknown",
        "name": "cancelMarker",
        "isRest": false,
        "hasDefault": false,
        "isOptional": false
      },
      {
        "name": "paymentCondition",
        "isRest": false,
        "isOptional": false,
        "type": "string",
        "hasDefault": false
      }
    ],
    "content": "/**\n * Excel equivalent:\n * =IF(ISBLANK(BY),\n *     IFERROR(VLOOKUP(Q, PaymentTerms, \"Available Payment Terms\"), \"\"),\n *     \"Cancelled\")\n *\n * @param cancelMarker   (BY column) if non-blank => \"Cancelled\"\n * @param paymentCondition (Q column) one of \"Invalid Booking\", \"Last Minute Booking\", \"Standard Booking, P1-4\"\n * @returns string: Available Payment Term, \"\" if not found, or \"Cancelled\" if cancelled\n */\n\nconst paymentTerms = [\n  { condition: \"Invalid Booking\", available: \"Invalid\" },\n  { condition: \"Last Minute Booking\", available: \"Full payment required within 48hrs\" },\n  { condition: \"Standard Booking, P1\", available: \"P1\" },\n  { condition: \"Standard Booking, P2\", available: \"P2\" },\n  { condition: \"Standard Booking, P3\", available: \"P3\" },\n  { condition: \"Standard Booking, P4\", available: \"P4\" },\n];\n\nexport default function availablePaymentTerm(\n  cancelMarker: unknown,\n  paymentCondition: string | null | undefined\n): string {\n  const isBlankLike = (v: unknown) =>\n    v === null || v === undefined || (typeof v === \"string\" && v.trim() === \"\");\n\n  // If BY is not blank â†’ \"Cancelled\"\n  if (!isBlankLike(cancelMarker)) return \"Cancelled\";\n\n  // If payment condition is blank\n  if (!paymentCondition || paymentCondition.trim() === \"\") return \"\";\n\n  const target = paymentCondition.trim().toLowerCase();\n\n  const found = paymentTerms.find(\n    t => t.condition.trim().toLowerCase() === target\n  );\n\n  return found ? found.available : \"\";\n}\n",
    "hasDestructuring": false,
    "hasRestParameters": false,
    "name": "availablePaymentTerm.ts",
    "fileType": "typescript",
    "functionName": "availablePaymentTerm",
    "hasUnionTypes": false,
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1758000099,
      "nanoseconds": 61000000
    },
    "hasTypeAnnotations": true,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "parameterCount": 2
  },
  {
    "id": "jSptJPyeP0httIjeVNUH",
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757865700,
      "nanoseconds": 414000000
    },
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757865664,
      "nanoseconds": 146000000
    },
    "arguments": [
      {
        "isOptional": false,
        "name": "bookingType",
        "hasDefault": false,
        "isRest": false,
        "type": "string"
      }
    ],
    "hasExportDefault": true,
    "parameterCount": 1,
    "hasTypeAnnotations": true,
    "hasGenerics": false,
    "name": "bookingCode.ts",
    "hasIntersectionTypes": false,
    "complexity": "simple",
    "isActive": false,
    "fileType": "typescript",
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "exportType": "function",
    "functionName": "bookingCodeColumn",
    "content": "/**\n * Replicates the Excel formula:\n * =IF(L=\"Single Booking\",\"SB\",IF(L=\"Duo Booking\",\"DB\",IF(L=\"Group Booking\",\"GB\",\"\")))\n *\n * Logic:\n *  - If bookingType = \"Single Booking\" -> \"SB\"\n *  - If bookingType = \"Duo Booking\"    -> \"DB\"\n *  - If bookingType = \"Group Booking\"  -> \"GB\"\n *  - Else -> \"\"\n */\nexport default function bookingCodeColumn(bookingType: string | null | undefined): string {\n  if (!bookingType) return \"\";\n\n  if (bookingType === \"Single Booking\") return \"SB\";\n  if (bookingType === \"Duo Booking\") return \"DB\";\n  if (bookingType === \"Group Booking\") return \"GB\";\n\n  return \"\";\n}\n",
    "hasRestParameters": false,
    "hasUnionTypes": false,
    "hasDestructuring": false,
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757865700,
      "nanoseconds": 414000000
    }
  },
  {
    "id": "ijP8aQvTkrN40y8vUagz",
    "functionDependencies": [
      "trim",
      "filter",
      "toString"
    ],
    "hasGenerics": false,
    "complexity": "moderate",
    "hasUnionTypes": false,
    "fileType": "typescript",
    "isActive": false,
    "hasRestParameters": false,
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759091833,
      "nanoseconds": 59000000
    },
    "exportType": "function",
    "parameterCount": 7,
    "content": "/**\n * Replicates the Excel formula:\n * =IF(N=\"\",\"\",IF(COUNTA(L:T)<6,\"\", B & \"-\" & C & \"-\" & D & \"-\" & E & F))\n *\n * Logic:\n *  - If tourDate is blank -> return \"\"\n *  - If supportingFields count < 6 -> return \"\"\n *  - Else -> bookingId-customerId-packageId-inquiryIdsequenceNumber\n */\nexport default function generateBookingReference(\n  tourDate: string | null | undefined,\n  supportingFields: (string | null | undefined)[],\n  bookingCode: string,\n  tourCode: string,\n  formattedDate: string,\n  travelsInitial: string,\n  tourPackageUniqueCounter: string\n): string {\n  // If tour date is blank\n  if (!tourDate || tourDate.trim() === \"\") return \"\";\n\n  // Count how many supporting fields are non-empty\n  const count = supportingFields.filter(\n    v => v !== null && v !== undefined && v.toString().trim() !== \"\"\n  ).length;\n  if (count < 6) return \"\";\n\n  // Concatenate values with hyphens (note: inquiryId and sequenceNumber have no hyphen between them)\n  return `${bookingCode}-${tourCode}-${formattedDate}-${travelsInitial}${tourPackageUniqueCounter}`;\n}\n",
    "arguments": [
      {
        "type": "string",
        "name": "tourDate",
        "hasDefault": false,
        "isRest": false,
        "isOptional": false
      },
      {
        "hasDefault": false,
        "type": "{}",
        "isRest": false,
        "isOptional": false,
        "name": "supportingFields"
      },
      {
        "isOptional": false,
        "name": "bookingCode",
        "hasDefault": false,
        "type": "string",
        "isRest": false
      },
      {
        "isRest": false,
        "hasDefault": false,
        "name": "tourCode",
        "isOptional": false,
        "type": "string"
      },
      {
        "isOptional": false,
        "isRest": false,
        "name": "formattedDate",
        "type": "string",
        "hasDefault": false
      },
      {
        "hasDefault": false,
        "name": "travelsInitial",
        "type": "string",
        "isRest": false,
        "isOptional": false
      },
      {
        "isOptional": false,
        "type": "string",
        "name": "tourPackageUniqueCounter",
        "isRest": false,
        "hasDefault": false
      }
    ],
    "functionName": "generateBookingReference",
    "hasIntersectionTypes": false,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "name": "bookingId.ts",
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757865482,
      "nanoseconds": 748000000
    },
    "hasDestructuring": false,
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759091833,
      "nanoseconds": 59000000
    },
    "hasTypeAnnotations": true,
    "hasExportDefault": true
  },
  {
    "id": "04iOigQVQJXqE1Ht4yw2",
    "isActive": true,
    "parameterCount": 2,
    "hasGenerics": false,
    "exportType": "function",
    "arguments": [
      {
        "hasDefault": false,
        "type": "unknown",
        "isOptional": false,
        "isRest": false,
        "name": "reservationDate"
      },
      {
        "name": "tourDate",
        "isOptional": false,
        "hasDefault": false,
        "type": "unknown",
        "isRest": false
      }
    ],
    "hasRestParameters": false,
    "name": "daysBetweenReservationAndTour.ts",
    "hasExportDefault": true,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757997985,
      "nanoseconds": 373000000
    },
    "fileType": "typescript",
    "hasUnionTypes": false,
    "functionName": "daysBetweenReservationAndTour",
    "hasIntersectionTypes": false,
    "hasTypeAnnotations": true,
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757998007,
      "nanoseconds": 433000000
    },
    "content": "/**\n * Excel equivalent:\n * =IF(AND(K<>\"\", N<>\"\"), N - K, \"\")\n *\n * - K = Reservation Date\n * - N = Tour Date\n * - Returns: number of days between (N - K), or \"\" if blank/invalid\n */\nexport default function daysBetweenReservationAndTour(\n  reservationDate: unknown,\n  tourDate: unknown\n): number | \"\" {\n  const toDate = (input: unknown): Date | null => {\n    if (input === null || input === undefined) return null;\n    if (typeof input === \"string\" && input.trim() === \"\") return null;\n\n    try {\n      if (\n        typeof input === \"object\" &&\n        input !== null &&\n        \"toDate\" in (input as any) &&\n        typeof (input as any).toDate === \"function\"\n      ) {\n        return (input as any).toDate();\n      }\n      if (\n        typeof input === \"object\" &&\n        input !== null &&\n        \"seconds\" in (input as any) &&\n        typeof (input as any).seconds === \"number\"\n      ) {\n        const s = (input as any).seconds as number;\n        const ns =\n          typeof (input as any).nanoseconds === \"number\"\n            ? (input as any).nanoseconds\n            : 0;\n        return new Date(s * 1000 + Math.floor(ns / 1e6));\n      }\n      if (input instanceof Date) return input;\n      if (typeof input === \"number\") return new Date(input);\n      if (typeof input === \"string\") {\n        const raw = input.trim();\n        if (/^\\d{2}\\/\\d{2}\\/\\d{4}$/.test(raw)) {\n          const [dd, mm, yyyy] = raw.split(\"/\").map(Number);\n          return new Date(yyyy, mm - 1, dd);\n        }\n        if (/^\\d{4}-\\d{2}-\\d{2}$/.test(raw)) {\n          const [yyyy, mm, dd] = raw.split(\"-\").map(Number);\n          return new Date(yyyy, mm - 1, dd);\n        }\n        return new Date(raw);\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  };\n\n  const res = toDate(reservationDate);\n  const tour = toDate(tourDate);\n\n  if (!res || isNaN(res.getTime()) || !tour || isNaN(tour.getTime())) return \"\";\n\n  const msPerDay = 1000 * 60 * 60 * 24;\n  const diff = Math.round((tour.getTime() - res.getTime()) / msPerDay);\n\n  return diff;\n}\n",
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757998007,
      "nanoseconds": 433000000
    },
    "complexity": "simple",
    "hasDestructuring": false
  },
  {
    "id": "NEF6QLxcXoZKKwDZgsrq",
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "hasRestParameters": false,
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757998486,
      "nanoseconds": 168000000
    },
    "exportType": "function",
    "arguments": [
      {
        "type": "unknown",
        "isRest": false,
        "name": "reservationDate",
        "hasDefault": false,
        "isOptional": false
      },
      {
        "isOptional": false,
        "isRest": false,
        "type": "unknown",
        "hasDefault": false,
        "name": "tourDate"
      }
    ],
    "hasUnionTypes": false,
    "isActive": false,
    "hasTypeAnnotations": true,
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757998454,
      "nanoseconds": 679000000
    },
    "hasExportDefault": true,
    "fileType": "typescript",
    "hasDestructuring": false,
    "content": "/**\n * Excel equivalent:\n * =IF(OR(ISBLANK(K), ISBLANK(N)), \"\",\n *   LET(\n *     resDate, K,\n *     tourDate, N,\n *     fullPaymentDue, tourDate - 30,\n *     monthCount, MAX(0, DATEDIF(resDate, fullPaymentDue, \"M\") + 1),\n *     secondDates, DATE(YEAR(resDate), MONTH(resDate) + SEQUENCE(monthCount), 2),\n *     validDates, FILTER(secondDates, (secondDates >= resDate + 3) * (secondDates <= fullPaymentDue)),\n *     IF(ISERROR(validDates), 0, COUNTA(validDates))\n *   )\n * )\n *\n * Returns: number | \"\"  (empty string if either date is blank/invalid)\n */\nexport default function eligibleSecondsCount(\n  reservationDate: unknown, // K\n  tourDate: unknown         // N\n): number | \"\" {\n  // ---------- local helpers (robust parsing like our previous funcs) ----------\n  const toDate = (input: unknown): Date | null => {\n    if (input === null || input === undefined) return null;\n    if (typeof input === \"string\" && input.trim() === \"\") return null;\n\n    try {\n      // Firestore Timestamp (has .toDate())\n      if (\n        typeof input === \"object\" &&\n        input !== null &&\n        \"toDate\" in (input as any) &&\n        typeof (input as any).toDate === \"function\"\n      ) {\n        const d = (input as any).toDate();\n        return isNaN(d.getTime()) ? null : d;\n      }\n\n      // Firestore-like { seconds, nanoseconds? }\n      if (\n        typeof input === \"object\" &&\n        input !== null &&\n        \"seconds\" in (input as any) &&\n        typeof (input as any).seconds === \"number\"\n      ) {\n        const s = (input as any).seconds as number;\n        const ns =\n          typeof (input as any).nanoseconds === \"number\"\n            ? (input as any).nanoseconds\n            : 0;\n        const d = new Date(s * 1000 + Math.floor(ns / 1e6));\n        return isNaN(d.getTime()) ? null : d;\n      }\n\n      // Already a Date\n      if (input instanceof Date) return isNaN(input.getTime()) ? null : input;\n\n      // Milliseconds timestamp\n      if (typeof input === \"number\") {\n        const d = new Date(input);\n        return isNaN(d.getTime()) ? null : d;\n      }\n\n      // String formats\n      if (typeof input === \"string\") {\n        const raw = input.trim();\n\n        // dd/mm/yyyy\n        if (/^\\d{2}\\/\\d{2}\\/\\d{4}$/.test(raw)) {\n          const [dd, mm, yyyy] = raw.split(\"/\").map(Number);\n          const d = new Date(yyyy, mm - 1, dd);\n          return isNaN(d.getTime()) ? null : d;\n        }\n\n        // yyyy-mm-dd\n        if (/^\\d{4}-\\d{2}-\\d{2}$/.test(raw)) {\n          const [yyyy, mm, dd] = raw.split(\"-\").map(Number);\n          const d = new Date(yyyy, mm - 1, dd);\n          return isNaN(d.getTime()) ? null : d;\n        }\n\n        // Natural/ISO strings (incl. \"UTC+8\")\n        const d = new Date(raw);\n        return isNaN(d.getTime()) ? null : d;\n      }\n\n      return null;\n    } catch {\n      return null;\n    }\n  };\n\n  const startOfDay = (d: Date) => new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\n  const addDays = (base: Date, days: number): Date => {\n    const out = new Date(base);\n    out.setDate(out.getDate() + days);\n    return out;\n  };\n\n  // Similar behavior to DATEDIF(res, end, \"M\")\n  const monthsBetweenInclusiveStart = (a: Date, b: Date): number => {\n    const years = b.getFullYear() - a.getFullYear();\n    const months = b.getMonth() - a.getMonth();\n    let diff = years * 12 + months;\n    if (b.getDate() < a.getDate()) diff -= 1;\n    return Math.max(0, diff);\n  };\n\n  const generateMonthSeconds = (start: Date, count: number): Date[] => {\n    const list: Date[] = [];\n    for (let i = 0; i < count; i++) {\n      list.push(new Date(start.getFullYear(), start.getMonth() + i, 2));\n    }\n    return list;\n  };\n\n  // ---------- apply logic ----------\n  const res = toDate(reservationDate);\n  const tour = toDate(tourDate);\n  if (!res || !tour) return \"\";\n\n  const resD = startOfDay(res);\n  const tourD = startOfDay(tour);\n\n  const fullPaymentDue = addDays(tourD, -30);           // tourDate - 30\n  const windowStart = addDays(resD, 3);                 // resDate + 3\n\n  // monthCount = MAX(0, DATEDIF(resDate, fullPaymentDue, \"M\") + 1)\n  const monthCount = Math.max(0, monthsBetweenInclusiveStart(resD, fullPaymentDue) + 1);\n\n  // secondDates = DATE(YEAR(resDate), MONTH(resDate) + SEQUENCE(monthCount), 2)\n  const seconds = generateMonthSeconds(resD, monthCount);\n\n  // validDates: seconds within [res+3, fullPaymentDue]\n  const eligible = seconds.filter(d => d >= windowStart && d <= fullPaymentDue);\n\n  // IF(ISERROR(validDates), 0, COUNTA(validDates))\n  // In JS, filter won't error; count is just eligible.length\n  return eligible.length;\n}\n",
    "functionName": "eligibleSecondsCount",
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757998486,
      "nanoseconds": 168000000
    },
    "hasIntersectionTypes": false,
    "hasGenerics": false,
    "parameterCount": 2,
    "name": "eligibleSecondsCount.ts",
    "complexity": "simple"
  },
  {
    "id": "ZIeBZVrVFdisM7pXqWZQ",
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757868221,
      "nanoseconds": 788000000
    },
    "hasGenerics": false,
    "hasRestParameters": false,
    "content": "/**\n * Excel equivalent: =IF(N=\"\",\"\",TEXT(N,\"yyyymmdd\"))\n *\n * Accepts:\n *  - null/undefined/\"\" -> returns \"\"\n *  - Date\n *  - number (ms since epoch)\n *  - string (\"September 15, 2025 at 8:00:00 AM UTC+8\", \"15/09/2025\", \"2025-09-15\")\n *  - Firestore Timestamp (has .toDate())\n *  - { seconds: number, nanoseconds?: number } shape\n *\n * Returns:\n *  - \"yyyymmdd\" for valid inputs\n *  - \"ERROR\" for invalid inputs\n */\nexport default function tourDateToYyyymmdd(tourDate: unknown): string {\n    // 1) Blank handling\n    if (tourDate === null || tourDate === undefined) return \"\";\n    if (typeof tourDate === \"string\" && tourDate.trim() === \"\") return \"\";\n\n    // 2) Try to normalize to a Date\n    let date: Date | null = null;\n\n    try {\n        // Firestore Timestamp: has .toDate()\n        if (typeof tourDate === \"object\" && tourDate !== null && \"toDate\" in (tourDate as any) && typeof (tourDate as any).toDate === \"function\") {\n            date = (tourDate as any).toDate();\n        }\n        // Firestore-like { seconds, nanoseconds }\n        else if (\n            typeof tourDate === \"object\" &&\n            tourDate !== null &&\n            \"seconds\" in (tourDate as any) &&\n            typeof (tourDate as any).seconds === \"number\"\n        ) {\n            const s = (tourDate as any).seconds as number;\n            const ns = typeof (tourDate as any).nanoseconds === \"number\" ? (tourDate as any).nanoseconds : 0;\n            date = new Date(s * 1000 + Math.floor(ns / 1e6));\n        }\n        // Already a Date\n        else if (tourDate instanceof Date) {\n            date = tourDate;\n        }\n        // Milliseconds timestamp\n        else if (typeof tourDate === \"number\") {\n            const d = new Date(tourDate);\n            date = isNaN(d.getTime()) ? null : d;\n        }\n        // String inputs\n        else if (typeof tourDate === \"string\") {\n            const raw = tourDate.trim();\n\n            // dd/mm/yyyy\n            if (/^\\d{2}\\/\\d{2}\\/\\d{4}$/.test(raw)) {\n                const [dd, mm, yyyy] = raw.split(\"/\").map(Number);\n                date = new Date(yyyy, mm - 1, dd);\n            }\n            // yyyy-mm-dd\n            else if (/^\\d{4}-\\d{2}-\\d{2}$/.test(raw)) {\n                const [yyyy, mm, dd] = raw.split(\"-\").map(Number);\n                date = new Date(yyyy, mm - 1, dd);\n            }\n            // Natural/ISO strings (includes \"UTC+8\")\n            else {\n                const parsed = new Date(raw);\n                date = isNaN(parsed.getTime()) ? null : parsed;\n            }\n        }\n\n        // 3) Validate\n        if (!date || isNaN(date.getTime())) return \"ERROR\";\n\n        // 4) Format yyyymmdd\n        const y = date.getFullYear();\n        const m = String(date.getMonth() + 1).padStart(2, \"0\");\n        const d = String(date.getDate()).padStart(2, \"0\");\n        return `${y}-${m}-${d}`;\n    } catch {\n        return \"ERROR\";\n    }\n}\n",
    "isActive": false,
    "hasIntersectionTypes": false,
    "hasDestructuring": false,
    "functionName": "tourDateToYyyymmdd",
    "complexity": "simple",
    "exportType": "function",
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757868221,
      "nanoseconds": 788000000
    },
    "hasUnionTypes": false,
    "hasTypeAnnotations": true,
    "name": "formattedDate.ts",
    "hasExportDefault": true,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "fileType": "typescript",
    "parameterCount": 1,
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757867466,
      "nanoseconds": 293000000
    },
    "arguments": [
      {
        "type": "unknown",
        "isRest": false,
        "isOptional": false,
        "name": "tourDate",
        "hasDefault": false
      }
    ]
  },
  {
    "id": "sxT6wbtgSiUwho941kXh",
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "arguments": [
      {
        "isRest": false,
        "type": "string",
        "hasDefault": false,
        "name": "f",
        "isOptional": false
      },
      {
        "type": "string",
        "name": "l",
        "hasDefault": false,
        "isOptional": false,
        "isRest": false
      }
    ],
    "functionName": "fullNamets",
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759058361,
      "nanoseconds": 212000000
    },
    "hasDestructuring": false,
    "hasIntersectionTypes": false,
    "complexity": "simple",
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757868990,
      "nanoseconds": 67000000
    },
    "hasTypeAnnotations": true,
    "content": "// fullName.ts\n// Created on 9/15/2025\n// TypeScript file with export default function\n\nexport default function fullNamets(\n  f: string | undefined | null,\n  l: string | undefined | null\n) {\n    if (f != null && l != null) {\n        return `${f} ${l}`\n    }\n\n    return \"\"  \n}",
    "hasExportDefault": true,
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759058361,
      "nanoseconds": 212000000
    },
    "parameterCount": 2,
    "fileType": "typescript",
    "exportType": "function",
    "hasRestParameters": false,
    "name": "fullName.ts",
    "hasUnionTypes": false,
    "hasGenerics": false,
    "functionDependencies": [],
    "isActive": false
  },
  {
    "id": "sF93bd9J5Y0vV1xBqseV",
    "arguments": [
      {
        "name": "fullName",
        "hasDefault": false,
        "isRest": false,
        "type": "string",
        "isOptional": false
      }
    ],
    "hasDestructuring": false,
    "complexity": "simple",
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759102935,
      "nanoseconds": 441000000
    },
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759102935,
      "nanoseconds": 441000000
    },
    "hasRestParameters": false,
    "hasTypeAnnotations": true,
    "hasIntersectionTypes": false,
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759102895,
      "nanoseconds": 458000000
    },
    "fileType": "typescript",
    "functionDependencies": [],
    "hasGenerics": false,
    "functionName": "fullName2",
    "exportType": "function",
    "content": "// fullName.ts\n// Created on 9/15/2025\n// TypeScript file with export default function\n\nexport default function fullName2(\n  fullName: string | undefined | null,\n) {\n  return fullName\n}",
    "parameterCount": 1,
    "hasUnionTypes": false,
    "name": "fullName2.ts",
    "hasExportDefault": true,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "isActive": false
  },
  {
    "id": "gzdYxQzZCNawiMAZATPg",
    "arguments": [
      {
        "type": "string",
        "isOptional": false,
        "isRest": false,
        "name": "bookingId",
        "hasDefault": false
      },
      {
        "type": "boolean",
        "isRest": false,
        "isOptional": false,
        "name": "includeBcc",
        "hasDefault": false
      },
      {
        "type": "string",
        "isOptional": false,
        "name": "emailAddress",
        "hasDefault": false,
        "isRest": false
      },
      {
        "type": "boolean",
        "hasDefault": false,
        "isRest": false,
        "name": "generateEmailDraft",
        "isOptional": false
      }
    ],
    "functionName": "generateEmailDraft",
    "fileType": "typescript",
    "functionDependencies": [
      "getCollectionData",
      "filter",
      "log",
      "deleteDocument",
      "updateDocument",
      "httpsCallable",
      "generateEmail",
      "error"
    ],
    "hasTypeAnnotations": true,
    "name": "generateEmailDraft.ts",
    "hasGenerics": false,
    "complexity": "moderate",
    "hasExportDefault": true,
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759307618,
      "nanoseconds": 746000000
    },
    "hasUnionTypes": false,
    "parameterCount": 4,
    "hasRestParameters": false,
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759307618,
      "nanoseconds": 746000000
    },
    "content": "export default async function generateEmailDraft(\n  bookingId: string,\n  includeBcc: boolean | null,\n  emailAddress: string,\n  generateEmailDraft: boolean\n): Promise<string> {\n  try {\n    // Get all bookings and filter client-side\n    const bookings = await firebaseUtils.getCollectionData(\"bookings\");\n\n    if (!bookingId) return \"\";\n\n    // Filter to find the booking with matching bookingId AND emailAddress\n    const matchingBookings = bookings.filter(booking =>\n      booking.bookingId === bookingId &&\n      booking.emailAddress === emailAddress\n    );\n\n    if (!matchingBookings || matchingBookings.length === 0) {\n      throw new Error(`Booking with bookingId ${bookingId} and email ${emailAddress} not found`);\n    }\n\n    // Get the first matching booking document\n    const bookingDoc = matchingBookings[0];\n\n    console.log(`Found booking document with ID: ${bookingDoc.id}`);\n\n    // Check if booking already has an email draft\n    const existingEmailDraftId = bookingDoc.emailDraftLink || bookingDoc.cancellationEmailDraftId;\n\n    console.log(\"Email is existing: \", existingEmailDraftId)\n\n    if (existingEmailDraftId) {\n      if (generateEmailDraft) {\n        // Return existing draft ID if Generate Email Draft is true\n        console.log(`Returning existing email draft: ${existingEmailDraftId}`);\n        return existingEmailDraftId;\n      } else {\n        // Delete existing draft if Generate Email Draft is false\n        console.log(`Deleting existing email draft: ${existingEmailDraftId}`);\n        await firebaseUtils.deleteDocument(\"emailDrafts\", existingEmailDraftId);\n\n        // Update booking to remove draft reference using document ID\n        await firebaseUtils.updateDocument(\"bookings\", bookingDoc.id, {\n          emailDraftId: null,\n          cancellationEmailDraftId: null,\n          generateEmailDraft: false\n        });\n\n        return \"\";\n      }\n    }\n\n    // If no existing draft and Generate Email Draft is true, create new draft\n    if (generateEmailDraft) {\n      console.log(`Generating new email draft for booking: ${bookingId}`);\n\n      // Use the REAL Firebase Functions client instead of the mock\n      const generateEmail = httpsCallable(functions, 'generateReservationEmail');\n\n      try {\n        const emailResult = await generateEmail({\n          bookingId: bookingDoc.id, // Use the document ID, not the bookingId field\n          generateDraftCell: true\n        });\n\n        console.log('Real function result:', emailResult.data);\n\n        if (emailResult.data && emailResult.data.success) {\n          const draftId = emailResult.data.draftId || \"\";\n          console.log(`Generated email draft with ID: ${draftId}`);\n          return draftId;\n        } else {\n          console.error('Function returned unsuccessful result:', emailResult.data);\n          throw new Error(\"Failed to generate reservation email draft\");\n        }\n      } catch (functionError) {\n        console.error('Error calling generateReservationEmail function:', functionError);\n\n        // Log detailed error information\n        if (functionError.code) {\n          console.error('Error code:', functionError.code);\n        }\n        if (functionError.message) {\n          console.error('Error message:', functionError.message);\n        }\n        if (functionError.details) {\n          console.error('Error details:', functionError.details);\n        }\n\n        // Re-throw with more context\n        throw new Error(`Cloud function error: ${functionError.code || 'unknown'} - ${functionError.message || 'Unknown error'}`);\n      }\n    }\n\n    // If Generate Email Draft is false and no existing draft, return empty string\n    console.log(`No action needed - Generate Email Draft is false and no existing draft`);\n    return \"\";\n\n  } catch (error) {\n    console.error(\"Error in generateEmailDraft:\", error);\n    throw error;\n  }\n}",
    "isActive": false,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "hasIntersectionTypes": false,
    "hasDestructuring": false,
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759089917,
      "nanoseconds": 403000000
    },
    "exportType": "function"
  },
  {
    "id": "wwQi6z9ayC4izgDYhHjM",
    "hasDestructuring": false,
    "name": "getSubjectLineReservation.ts",
    "hasUnionTypes": false,
    "content": "/**\n * Fetch the subject from an email draft by its ID.\n *\n * @param draftLinkId Document ID of the draft in emailDrafts collection\n * @returns Subject string if found, \"\" if missing, \"ERROR\" if not found\n */\nexport default async function getEmailDraftSubject(\n  draftLinkId: string\n): Promise<string> {\n  if (!draftLinkId || draftLinkId.trim() === \"\") return \"\";\n\n  try {\n    const drafts = await firebaseUtils.getCollectionData(\"emailDrafts\");\n\n    const draft = drafts.find((d: any) => d.id === draftLinkId);\n\n    if (!draft) return \"ERROR\";\n    return draft.subject ?? \"\";\n  } catch (err) {\n    console.error(\"Failed to fetch email draft:\", err);\n    return \"ERROR\";\n  }\n}\n",
    "complexity": "simple",
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "exportType": "function",
    "arguments": [
      {
        "isOptional": false,
        "hasDefault": false,
        "name": "draftLinkId",
        "type": "string",
        "isRest": false
      }
    ],
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759168066,
      "nanoseconds": 758000000
    },
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759168307,
      "nanoseconds": 213000000
    },
    "hasRestParameters": false,
    "functionDependencies": [
      "trim",
      "getCollectionData",
      "find",
      "error"
    ],
    "hasGenerics": false,
    "hasIntersectionTypes": false,
    "isActive": false,
    "hasExportDefault": true,
    "parameterCount": 1,
    "fileType": "typescript",
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759168307,
      "nanoseconds": 213000000
    },
    "hasTypeAnnotations": true,
    "functionName": "getEmailDraftSubject"
  },
  {
    "id": "jcKaPYU6xDH67PzB5NzB",
    "fileType": "javascript",
    "parameterCount": 6,
    "hasExportDefault": true,
    "arguments": [
      {
        "hasDefault": false,
        "type": "string",
        "name": "bookingType",
        "isOptional": false,
        "isRest": false
      },
      {
        "isRest": false,
        "isOptional": false,
        "hasDefault": false,
        "name": "tourName",
        "type": "string"
      },
      {
        "isRest": false,
        "name": "firstName",
        "hasDefault": false,
        "type": "string",
        "isOptional": false
      },
      {
        "isRest": false,
        "hasDefault": false,
        "type": "string",
        "isOptional": false,
        "name": "lastName"
      },
      {
        "name": "email",
        "type": "string",
        "isOptional": false,
        "isRest": false,
        "hasDefault": false
      },
      {
        "isRest": false,
        "isOptional": false,
        "hasDefault": false,
        "name": "isActive",
        "type": "boolean"
      }
    ],
    "hasUnionTypes": false,
    "complexity": "moderate",
    "content": "/**\n * Generate Group/Duo Booking Member ID (standalone version, no allRows needed).\n *\n * @param bookingType  \"Duo Booking\" | \"Group Booking\"\n * @param tourName     Tour package name\n * @param firstName    Traveller's first name\n * @param lastName     Traveller's last name\n * @param email        Traveller's email\n * @param isActive     Equivalent of U column (if false => \"\")\n * @returns string ID or \"\"\n */\nexport default function generateGroupMemberId(\n  bookingType: string,\n  tourName: string,\n  firstName: string,\n  lastName: string,\n  email: string,\n  isActive: boolean\n): string {\n  // Only Duo or Group bookings apply\n  if (!(bookingType === \"Duo Booking\" || bookingType === \"Group Booking\")) {\n    return \"\";\n  }\n  if (isActive == false) return \"\";\n\n  const initials =\n    (firstName?.[0] ?? \"\").toUpperCase() + (lastName?.[0] ?? \"\").toUpperCase();\n  const idPrefix = bookingType === \"Duo Booking\" ? \"DB\" : \"GB\";\n\n  // Hash based on email + traveller identity\n  const identity = `${bookingType}|${tourName}|${firstName}|${lastName}|${email}`;\n  let hashNum = 0;\n  for (let i = 0; i < identity.length; i++) {\n    hashNum += identity.charCodeAt(i) * (i + 1);\n  }\n  const hashTag = String(Math.abs(hashNum) % 10000).padStart(4, \"0\");\n\n  // Fake member number: derive from hash as a stable 001â€“999\n  const memberNumber = String((Math.abs(hashNum) % 999) + 1).padStart(3, \"0\");\n\n  return `${idPrefix}-${initials}-${hashTag}-${memberNumber}`;\n}\n",
    "hasGenerics": false,
    "name": "groupIdGenerator.ts",
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1758000504,
      "nanoseconds": 78000000
    },
    "exportType": "function",
    "hasTypeAnnotations": true,
    "functionName": "generateGroupMemberId",
    "hasDestructuring": false,
    "hasRestParameters": false,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759096073,
      "nanoseconds": 816000000
    },
    "hasIntersectionTypes": false,
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759096073,
      "nanoseconds": 816000000
    },
    "isActive": false,
    "functionDependencies": [
      "toUpperCase",
      "charCodeAt",
      "padStart",
      "String",
      "abs"
    ]
  },
  {
    "id": "eEPeF3AAICoe7tDKcdwr",
    "parameterCount": 3,
    "hasUnionTypes": false,
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757998852,
      "nanoseconds": 375000000
    },
    "hasDestructuring": false,
    "name": "paymentCondition.ts",
    "hasGenerics": false,
    "hasExportDefault": true,
    "hasTypeAnnotations": true,
    "fileType": "javascript",
    "hasRestParameters": false,
    "isActive": false,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1758000116,
      "nanoseconds": 478000000
    },
    "arguments": [
      {
        "isRest": false,
        "name": "tourDate",
        "isOptional": false,
        "hasDefault": false,
        "type": "unknown"
      },
      {
        "isRest": false,
        "name": "eligibleSecondCount",
        "isOptional": false,
        "type": "number",
        "hasDefault": false
      },
      {
        "name": "daysBetweenReservationAndTour",
        "isRest": false,
        "hasDefault": false,
        "type": "number",
        "isOptional": false
      }
    ],
    "complexity": "moderate",
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1758000116,
      "nanoseconds": 478000000
    },
    "functionName": "paymentCondition",
    "hasIntersectionTypes": false,
    "exportType": "function",
    "content": "/**\n * Excel equivalent:\n * =IF(ISBLANK(N),\"\",\n *   IFS(\n *     AND(R=0, S<2), \"Invalid Booking\",\n *     AND(R=0, S>=2), \"Last Minute Booking\",\n *     R=1, \"Standard Booking, P1\",\n *     R=2, \"Standard Booking, P2\",\n *     R=3, \"Standard Booking, P3\",\n *     R>=4, \"Standard Booking, P4\"\n *   )\n * )\n *\n * @param tourDate                  The tour date (N column)\n * @param eligibleSecondCount       The number of eligible \"2nd of month\" dates (R column)\n * @param daysBetweenReservationAndTour  Days between reservation date and tour date (S column)\n * @returns \"\" | the payment condition string\n */\nexport default function paymentCondition(\n  tourDate: unknown,\n  eligibleSecondCount: number,\n  daysBetweenReservationAndTour: number\n): string {\n  const isBlankLike = (v: unknown) =>\n    v === null || v === undefined || (typeof v === \"string\" && v.trim() === \"\");\n\n  if (isBlankLike(tourDate)) return \"\";\n\n  if (\n    typeof eligibleSecondCount !== \"number\" ||\n    typeof daysBetweenReservationAndTour !== \"number\" ||\n    !isFinite(eligibleSecondCount) ||\n    !isFinite(daysBetweenReservationAndTour)\n  ) {\n    return \"\"; // fallback if inputs invalid\n  }\n\n  if (eligibleSecondCount === 0 && daysBetweenReservationAndTour < 2) {\n    return \"Invalid Booking\";\n  }\n  if (eligibleSecondCount === 0 && daysBetweenReservationAndTour >= 2) {\n    return \"Last Minute Booking\";\n  }\n  if (eligibleSecondCount === 1) return \"Standard Booking, P1\";\n  if (eligibleSecondCount === 2) return \"Standard Booking, P2\";\n  if (eligibleSecondCount === 3) return \"Standard Booking, P3\";\n  if (eligibleSecondCount >= 4) return \"Standard Booking, P4\";\n\n  return \"\";\n}\n"
  },
  {
    "id": "RWgqWzjUm9haopehL5Bt",
    "fileType": "typescript",
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757997415,
      "nanoseconds": 53000000
    },
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757997731,
      "nanoseconds": 502000000
    },
    "isActive": false,
    "parameterCount": 2,
    "hasIntersectionTypes": false,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757997731,
      "nanoseconds": 502000000
    },
    "complexity": "simple",
    "arguments": [
      {
        "name": "tourDate",
        "hasDefault": false,
        "type": "unknown",
        "isRest": false,
        "isOptional": false
      },
      {
        "type": "number",
        "name": "durationDays",
        "hasDefault": false,
        "isRest": false,
        "isOptional": false
      }
    ],
    "hasGenerics": false,
    "content": "/**\n * Excel equivalent:\n * =IF(N=\"\",\"\",IFERROR(N + VALUE(REGEXEXTRACT(P, \"(\\d+)\\\\s+Days\")), \"\"))\n *\n * - N = tourDate (robust parsing like tourDateToYyyymmdd)\n * - P = durationDays (number of days from tourDurationByName)\n * - Returns: \"yyyy-mm-dd\" (end date) or \"\" if blank/error\n */\nexport default function tourEndDateFromStartAndDuration(\n  tourDate: unknown,\n  durationDays: number\n): string {\n  // --- helpers ---\n  const toDate = (input: unknown): Date | null => {\n    if (input === null || input === undefined) return null;\n    if (typeof input === \"string\" && input.trim() === \"\") return null;\n\n    try {\n      if (\n        typeof input === \"object\" &&\n        input !== null &&\n        \"toDate\" in (input as any) &&\n        typeof (input as any).toDate === \"function\"\n      ) {\n        return (input as any).toDate();\n      }\n      if (\n        typeof input === \"object\" &&\n        input !== null &&\n        \"seconds\" in (input as any) &&\n        typeof (input as any).seconds === \"number\"\n      ) {\n        const s = (input as any).seconds as number;\n        const ns =\n          typeof (input as any).nanoseconds === \"number\"\n            ? (input as any).nanoseconds\n            : 0;\n        return new Date(s * 1000 + Math.floor(ns / 1e6));\n      }\n      if (input instanceof Date) return input;\n      if (typeof input === \"number\") return new Date(input);\n      if (typeof input === \"string\") {\n        const raw = input.trim();\n        if (/^\\d{2}\\/\\d{2}\\/\\d{4}$/.test(raw)) {\n          const [dd, mm, yyyy] = raw.split(\"/\").map(Number);\n          return new Date(yyyy, mm - 1, dd);\n        }\n        if (/^\\d{4}-\\d{2}-\\d{2}$/.test(raw)) {\n          const [yyyy, mm, dd] = raw.split(\"-\").map(Number);\n          return new Date(yyyy, mm - 1, dd);\n        }\n        return new Date(raw); // ISO or natural string\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  };\n\n  const toStartOfDay = (d: Date): Date =>\n    new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\n  const addDays = (base: Date, days: number): Date => {\n    const out = new Date(base);\n    out.setDate(out.getDate() + days);\n    return out;\n  };\n\n  const formatYYYYMMDD = (d: Date): string => {\n    const y = d.getFullYear();\n    const m = String(d.getMonth() + 1).padStart(2, \"0\");\n    const day = String(d.getDate()).padStart(2, \"0\");\n    return `${y}-${m}-${day}`;\n  };\n\n  // --- logic ---\n  const start = toDate(tourDate);\n  if (!start || isNaN(start.getTime())) return \"\";\n  if (typeof durationDays !== \"number\" || !Number.isFinite(durationDays)) return \"\";\n\n  const end = addDays(toStartOfDay(start), durationDays);\n  return formatYYYYMMDD(end);\n}\n",
    "hasUnionTypes": false,
    "exportType": "function",
    "functionName": "tourEndDateFromStartAndDuration",
    "hasExportDefault": true,
    "hasRestParameters": false,
    "hasDestructuring": false,
    "name": "returnDate.ts",
    "hasTypeAnnotations": true
  },
  {
    "id": "ZHx2xy9eB9YYbVTBaMse",
    "functionDependencies": [
      "trim",
      "getDocumentData",
      "updateDocument",
      "httpsCallable",
      "callSend",
      "String",
      "error"
    ],
    "hasExportDefault": true,
    "hasUnionTypes": false,
    "parameterCount": 2,
    "name": "sendReservationEmail.ts",
    "hasIntersectionTypes": false,
    "functionName": "sendEmailDraftOnce",
    "fileType": "typescript",
    "hasGenerics": false,
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759309642,
      "nanoseconds": 730000000
    },
    "exportType": "function",
    "complexity": "simple",
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759097617,
      "nanoseconds": 344000000
    },
    "isActive": false,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "hasTypeAnnotations": true,
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759309642,
      "nanoseconds": 730000000
    },
    "hasRestParameters": false,
    "hasDestructuring": false,
    "content": "/**\n * Safely send an email draft once (without runTransaction).\n *\n * @param draftLinkId Firestore doc ID in \"emailDrafts\"\n * @param sendEmail   Boolean flag, if false -> return \"\"\n * @returns \"\" if skipped, messageId if sent/already sent, \"ERROR\" if failure\n */\nexport default async function sendEmailDraftOnce(\n  draftLinkId: string,\n  sendEmail: boolean\n): Promise<string> {\n  if (!sendEmail) return \"\";\n  if (!draftLinkId || draftLinkId.trim() === \"\") return \"ERROR\";\n\n  try {\n    // 1) Load draft\n    const draft = await firebaseUtils.getDocumentData(\"emailDrafts\", draftLinkId);\n    if (!draft) return \"ERROR\";\n\n    // If already sent, short-circuit\n    if (draft.status === \"sent\") {\n      return typeof draft.messageId === \"string\" ? draft.messageId : \"\";\n    }\n\n    // If currently sending by another process, bail out\n    if (draft.status === \"sending\") {\n      return \"\";\n    }\n\n    // 2) Mark as \"sending\" (soft lock)\n    await firebaseUtils.updateDocument(\"emailDrafts\", draftLinkId, {\n      status: \"sending\",\n      updatedAt: new Date(),\n    });\n\n    // 3) Call Cloud Function to actually send\n    const callSend = httpsCallable(functions, \"sendReservationEmail\");\n    const result: any = await callSend({ draftId: draftLinkId });\n\n    if (result?.data?.success && typeof result.data.messageId === \"string\") {\n      return ${result.data.messageId};\n    }\n\n    // Unexpected result â†’ mark failed\n    await firebaseUtils.updateDocument(\"emailDrafts\", draftLinkId, {\n      status: \"failed\",\n      updatedAt: new Date(),\n      errorMessage: \"Unexpected Cloud Function response\",\n    });\n\n    return \"ERROR\";\n  } catch (err) {\n    // On error, mark failed (best-effort)\n    try {\n      await firebaseUtils.updateDocument(\"emailDrafts\", draftLinkId, {\n        status: \"failed\",\n        updatedAt: new Date(),\n        errorMessage: err instanceof Error ? err.message : String(err),\n      });\n    } catch (_) {\n      // ignore fallback error\n    }\n    console.error(\"sendEmailDraftOnce error:\", err);\n    return \"ERROR\";\n  }\n}\n",
    "arguments": [
      {
        "name": "draftLinkId",
        "isOptional": false,
        "type": "string",
        "hasDefault": false,
        "isRest": false
      },
      {
        "type": "boolean",
        "isRest": false,
        "hasDefault": false,
        "isOptional": false,
        "name": "sendEmail"
      }
    ]
  },
  {
    "id": "8wTSTvAyHfmd88yd2SdH",
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "hasRestParameters": false,
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759202527,
      "nanoseconds": 703000000
    },
    "functionDependencies": [
      "padStart",
      "String",
      "getHours",
      "getMinutes",
      "getSeconds"
    ],
    "exportType": "function",
    "arguments": [
      {
        "hasDefault": false,
        "type": "any",
        "isRest": false,
        "name": "returnTime",
        "isOptional": false
      }
    ],
    "hasUnionTypes": false,
    "isActive": false,
    "hasTypeAnnotations": false,
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759201934,
      "nanoseconds": 849000000
    },
    "hasExportDefault": true,
    "fileType": "javascript",
    "hasDestructuring": false,
    "content": "export default function getCurrentTimeWithSeconds(returnTime) {\n  if (!returnTime) {\n    return null; // or return undefined if you prefer\n  }\n\n  const now = new Date();\n\n  // Format as HH:MM:SS\n  const hours = String(now.getHours()).padStart(2, \"0\");\n  const minutes = String(now.getMinutes()).padStart(2, \"0\");\n  const seconds = String(now.getSeconds()).padStart(2, \"0\");\n\n  return `${hours}:${minutes}:${seconds}`;\n}\n\n// Example usage:\nconsole.log(getCurrentTimeWithSeconds(true));  // \"15:48:32\"\nconsole.log(getCurrentTimeWithSeconds(false)); // null\n",
    "functionName": "getCurrentTimeWithSeconds",
    "hasIntersectionTypes": false,
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759202527,
      "nanoseconds": 703000000
    },
    "hasGenerics": false,
    "parameterCount": 1,
    "name": "timeNow.ts",
    "complexity": "simple"
  },
  {
    "id": "LhdyWTqRZlHdfDYcN3Ar",
    "isActive": false,
    "parameterCount": 1,
    "exportType": "function",
    "hasGenerics": false,
    "arguments": [
      {
        "name": "tourPackageName",
        "isRest": false,
        "hasDefault": false,
        "isOptional": false,
        "type": "string"
      }
    ],
    "hasRestParameters": false,
    "name": "tourCode.ts",
    "hasExportDefault": true,
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757866799,
      "nanoseconds": 749000000
    },
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "fileType": "typescript",
    "hasUnionTypes": false,
    "functionDependencies": [
      "trim",
      "getCollectionData",
      "warn",
      "toLowerCase",
      "find",
      "error"
    ],
    "functionName": "lookupTourCode",
    "hasIntersectionTypes": false,
    "hasTypeAnnotations": true,
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1758913284,
      "nanoseconds": 619000000
    },
    "content": "// lookup-tour-code.ts\n// Created on 9/27/2025\n// TypeScript file with Firebase SDK access (pre-authenticated)\n\n// Firebase utilities - injected at runtime (hidden from user)\n// These variables are provided by the runtime environment\n// Users can use them without seeing the implementation details\n\n// Firebase utilities and services are automatically available\n// No need to import or define them - they're injected by the runtime\n\n/**\n * Lookup Tour Code by Tour Package Name\n * Fetches tour packages from Firebase and performs lookup\n *\n * Excel equivalent:\n * =IF(M=\"\",\"\",IFERROR(<lookup>, \"XXX\"))\n */\nexport default async function lookupTourCode(\n  tourPackageName: string | null | undefined\n): Promise<string> {\n  // If blank -> \"\"\n  if (!tourPackageName || tourPackageName.trim() === \"\") return \"\";\n\n  try {\n    // Fetch tour packages from Firebase\n    const tourPackages = await firebaseUtils.getCollectionData('tourPackages');\n\n    if (!tourPackages || tourPackages.length === 0) {\n      console.warn(\"No tour packages found in Firebase\");\n      return \"XXX\";\n    }\n\n    const target = tourPackageName.trim().toLowerCase();\n\n    const found = tourPackages.find(\n      (p: any) => p.name && p.name.trim().toLowerCase() === target\n    );\n\n    return found ? found.tourCode : \"XXX\";\n  } catch (error) {\n    console.error(\"Error fetching tour packages:\", error);\n    return \"XXX\";\n  }\n}\n",
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1758913284,
      "nanoseconds": 619000000
    },
    "complexity": "simple",
    "hasDestructuring": false
  },
  {
    "id": "2rRo0dpHdjTYP7IPy7jK",
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757997126,
      "nanoseconds": 795000000
    },
    "hasGenerics": false,
    "isActive": false,
    "exportType": "function",
    "complexity": "simple",
    "hasExportDefault": true,
    "hasIntersectionTypes": false,
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757997064,
      "nanoseconds": 445000000
    },
    "arguments": [
      {
        "name": "tourPackageName",
        "isRest": false,
        "isOptional": false,
        "type": "string",
        "hasDefault": false
      }
    ],
    "content": "// Master list with durations (your JSON)\nconst tourPackagesWithDuration = [\n  { name: \"India Discovery Tour\", tourCode: \"IDD\", duration: 13 },\n  { name: \"Argentina's Wonders\", tourCode: \"ARW\", duration: 11 },\n  { name: \"Maldives Bucketlist\", tourCode: \"MLB\", duration: 8 },\n  { name: \"New Zealand Expedition\", tourCode: \"NZE\", duration: 15 },\n  { name: \"Tanzania Exploration\", tourCode: \"TXP\", duration: 10 },\n  { name: \"Sri Lanka Wander Tour\", tourCode: \"SLW\", duration: 12 },\n  { name: \"India Holi Festival Tour\", tourCode: \"IHF\", duration: 13 },\n  { name: \"Brazil's Treasures\", tourCode: \"BZT\", duration: 12 },\n  { name: \"Philippines Sunset\", tourCode: \"PSS\", duration: 11 },\n  { name: \"Philippine Sunrise\", tourCode: \"PHS\", duration: 11 },\n  { name: \"Siargao Island Adventure\", tourCode: \"SIA\", duration: 6 },\n  { name: \"Vietnam Expedition\", tourCode: \"VNE\", duration: 11 },\n];\n\n/**\n * Extract duration (days) by tour package name (column M).\n * Excel equivalent:\n * =IFERROR(INDEX(... MATCH(M, ... \"Tour Package Name\" ... ), MATCH(\"Duration\", headers, 0)), \"\")\n *\n * @param tourPackageName value from column M\n * @returns number (days) if found, or \"\" if blank/not found\n */\nexport default function tourDurationByName(\n  tourPackageName: string | null | undefined\n): number | \"\" {\n  if (!tourPackageName || tourPackageName.trim() === \"\") return \"\";\n\n  const target = tourPackageName.trim().toLowerCase();\n  const found = tourPackagesWithDuration.find(\n    p => p.name.trim().toLowerCase() === target\n  );\n\n  return found ? found.duration : \"\";\n}\n",
    "hasDestructuring": false,
    "hasRestParameters": false,
    "name": "tourDuration.ts",
    "fileType": "typescript",
    "functionName": "tourDurationByName",
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757997126,
      "nanoseconds": 795000000
    },
    "hasUnionTypes": false,
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "hasTypeAnnotations": true,
    "parameterCount": 1
  },
  {
    "id": "pu7KacJCDH7Zp70NH4aI",
    "exportType": "function",
    "hasRestParameters": false,
    "functionName": "tourPackageUniqueCounter",
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759055751,
      "nanoseconds": 566000000
    },
    "arguments": [
      {
        "isRest": false,
        "isOptional": false,
        "type": "string",
        "name": "tourPackageName",
        "hasDefault": false
      },
      {
        "type": "string",
        "hasDefault": false,
        "isOptional": false,
        "name": "emailAddress",
        "isRest": false
      },
      {
        "hasDefault": false,
        "name": "tourDate",
        "type": "unknown",
        "isRest": false,
        "isOptional": false
      }
    ],
    "name": "tourPackageNameUniqueCounter.ts",
    "hasExportDefault": true,
    "functionDependencies": [
      "trim",
      "toDate",
      "isNaN",
      "getTime",
      "floor",
      "test",
      "map",
      "split",
      "getCollectionData",
      "some",
      "toLowerCase",
      "where",
      "orderBy",
      "filter",
      "padStart",
      "String"
    ],
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "complexity": "moderate",
    "hasIntersectionTypes": false,
    "hasTypeAnnotations": true,
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1759055751,
      "nanoseconds": 566000000
    },
    "hasDestructuring": false,
    "content": "/**\n * Tour Package Unique Counter (by email, ordered by tour date)\n *\n * Excel-like intent:\n * - Scope to the same tourPackageName (M) and emailAddress (G)\n * - Count those whose tourDate is <= current row's tourDate\n * - Return as 3-digit string (\"001\", \"002\", ...)\n *\n * @param tourPackageName Current row's tour package name (M column)\n * @param emailAddress    Traveller's email (G column)\n * @param tourDate        Current row's tour date (can be string/Date/TS/Firestore Timestamp)\n * @returns \"\" if M/G blank, \"ERROR\" if invalid inputs, else \"000\"-formatted count\n */\nexport default async function tourPackageUniqueCounter(\n  tourPackageName: string | null | undefined,\n  emailAddress: string | null | undefined,\n  tourDate: unknown\n): Promise<string> {\n  // --- blank checks (Excel-style) ---\n  if (!tourPackageName || tourPackageName.trim() === \"\") return \"\";\n  if (!emailAddress || emailAddress.trim() === \"\") return \"\";\n\n  // --- normalize tourDate for comparison ---\n  const toDate = (input: unknown): Date | null => {\n    if (input === null || input === undefined) return null;\n    if (typeof input === \"string\" && input.trim() === \"\") return null;\n\n    try {\n      // Firestore Timestamp\n      if (\n        typeof input === \"object\" &&\n        input !== null &&\n        \"toDate\" in (input as any) &&\n        typeof (input as any).toDate === \"function\"\n      ) {\n        const d = (input as any).toDate();\n        return isNaN(d.getTime()) ? null : d;\n      }\n      // Firestore-like { seconds, nanoseconds }\n      if (\n        typeof input === \"object\" &&\n        input !== null &&\n        \"seconds\" in (input as any) &&\n        typeof (input as any).seconds === \"number\"\n      ) {\n        const s = (input as any).seconds as number;\n        const ns =\n          typeof (input as any).nanoseconds === \"number\"\n            ? (input as any).nanoseconds\n            : 0;\n        const d = new Date(s * 1000 + Math.floor(ns / 1e6));\n        return isNaN(d.getTime()) ? null : d;\n      }\n      if (input instanceof Date) return isNaN(input.getTime()) ? null : input;\n      if (typeof input === \"number\") {\n        const d = new Date(input);\n        return isNaN(d.getTime()) ? null : d;\n      }\n      if (typeof input === \"string\") {\n        const raw = input.trim();\n        // dd/mm/yyyy\n        if (/^\\d{2}\\/\\d{2}\\/\\d{4}$/.test(raw)) {\n          const [dd, mm, yyyy] = raw.split(\"/\").map(Number);\n          const d = new Date(yyyy, mm - 1, dd);\n          return isNaN(d.getTime()) ? null : d;\n        }\n        // yyyy-mm-dd\n        if (/^\\d{4}-\\d{2}-\\d{2}$/.test(raw)) {\n          const [yyyy, mm, dd] = raw.split(\"-\").map(Number);\n          const d = new Date(yyyy, mm - 1, dd);\n          return isNaN(d.getTime()) ? null : d;\n        }\n        const d = new Date(raw); // ISO/natural, respects \"UTC+8\" if present\n        return isNaN(d.getTime()) ? null : d;\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  };\n\n  const currentTourDate = toDate(tourDate);\n  if (!currentTourDate) return \"ERROR\";\n\n  // --- validate tour package exists in master (tourPackages) ---\n  const tourPackages = await firebaseUtils.getCollectionData(\"tourPackages\");\n  const inMaster = tourPackages.some(\n    (p: any) =>\n      typeof p?.name === \"string\" &&\n      p.name.trim().toLowerCase() === tourPackageName.trim().toLowerCase()\n  );\n  if (!inMaster) return \"ERROR\";\n\n  // --- fetch all bookings for (tourPackageName, emailAddress) ordered by tourDate ---\n  // NOTE: Firestore: if 'tourDate' is a Timestamp field, orderBy works directly.\n  // If it's a string date, ensure consistent comparable format (ISO).\n  const sameTourSameEmail = await firebaseUtils.getCollectionData(\"bookings\", [\n    where(\"tourPackageName\", \"==\", tourPackageName),\n    where(\"emailAddress\", \"==\", emailAddress),\n    orderBy(\"tourDate\", \"asc\"),\n  ]);\n\n  // --- count bookings with tourDate <= currentTourDate ---\n  const count = sameTourSameEmail.filter((b: any) => {\n    const d = toDate(b?.tourDate);\n    return d && d.getTime() <= currentTourDate.getTime();\n  }).length;\n\n  return String(count).padStart(3, \"0\");\n}",
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757868708,
      "nanoseconds": 113000000
    },
    "hasGenerics": false,
    "isActive": false,
    "hasUnionTypes": false,
    "fileType": "typescript",
    "parameterCount": 3
  },
  {
    "id": "oN7e6p0OHMXNw1M4pHVy",
    "createdAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757868325,
      "nanoseconds": 539000000
    },
    "hasGenerics": false,
    "fileType": "typescript",
    "hasIntersectionTypes": false,
    "content": "/**\n * Excel equivalent:\n * =UPPER(LEFT(H,1) & LEFT(I,1))\n *\n * @param firstName Traveller's first name (H column)\n * @param lastName  Traveller's last name (I column)\n * @returns Uppercased initials (2 letters) or \"\" if missing\n */\nexport default function travellerInitials(\n  firstName: string | null | undefined,\n  lastName: string | null | undefined\n): string {\n  const f = firstName && firstName.length > 0 ? firstName[0] : \"\";\n  const l = lastName && lastName.length > 0 ? lastName[0] : \"\";\n\n  const initials = (f + l).toUpperCase();\n\n  return initials;\n}\n",
    "parameterCount": 2,
    "updatedAt": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757868468,
      "nanoseconds": 640000000
    },
    "arguments": [
      {
        "name": "firstName",
        "isRest": false,
        "type": "string",
        "hasDefault": false,
        "isOptional": false
      },
      {
        "type": "string",
        "name": "lastName",
        "hasDefault": false,
        "isRest": false,
        "isOptional": false
      }
    ],
    "hasDestructuring": false,
    "hasExportDefault": true,
    "hasRestParameters": false,
    "hasUnionTypes": false,
    "complexity": "simple",
    "isActive": false,
    "hasTypeAnnotations": true,
    "name": "travellersInitial.ts",
    "functionName": "travellerInitials",
    "exportType": "function",
    "folderId": "2lbmRmaZCIXELy8nZysu",
    "lastModified": {
      "type": "firestore/timestamp/1.0",
      "seconds": 1757868468,
      "nanoseconds": 640000000
    }
  }
]